#include <stdio.h>#include <stdlib.h>#include <stdatomic.h>#include <pthread.h>#include <time.h>#include <unistd.h>// Define a linked list node for orderstypedef struct Order {    char type; // 'B' for Buy, 'S' for Sell    char ticker[6]; // Stock ticker (e.g., "AAPL")    int quantity;    double price;    struct Order* next;} Order;// Atomic pointers for Buy and Sell lists (ensuring lock-free concurrency)_Atomic(Order*) buy_head = NULL;_Atomic(Order*) sell_head = NULL;// Function to create a new orderOrder* create_order(char type, const char* ticker, int quantity, double price) {    Order* new_order = (Order*)malloc(sizeof(Order));    new_order->type = type;    snprintf(new_order->ticker, 6, "%s", ticker);    new_order->quantity = quantity;    new_order->price = price;    new_order->next = NULL;    return new_order;}// Lock-free insertion into the buy order list (sorted descending)void add_buy_order(const char* ticker, int quantity, double price) {    Order* new_order = create_order('B', ticker, quantity, price);    Order* prev = NULL;    Order* curr = atomic_load(&buy_head);    while (curr && curr->price > price) { // Descending order        prev = curr;        curr = curr->next;    }    new_order->next = curr;    if (prev) prev->next = new_order;    else atomic_store(&buy_head, new_order);}// Lock-free insertion into the sell order list (sorted ascending)void add_sell_order(const char* ticker, int quantity, double price) {    Order* new_order = create_order('S', ticker, quantity, price);    Order* prev = NULL;    Order* curr = atomic_load(&sell_head);    while (curr && curr->price < price) { // Ascending order        prev = curr;        curr = curr->next;    }    new_order->next = curr;    if (prev) prev->next = new_order;    else atomic_store(&sell_head, new_order);}// Match Buy & Sell orders (O(n) time complexity)void match_orders() {    Order* buy_ptr = atomic_load(&buy_head);    Order* sell_ptr = atomic_load(&sell_head);    while (buy_ptr && sell_ptr) {        if (buy_ptr->price >= sell_ptr->price) { // Match found            int trade_qty = (buy_ptr->quantity < sell_ptr->quantity) ? buy_ptr->quantity : sell_ptr->quantity;            printf("Trade executed: %d shares at $%.2f\n", trade_qty, sell_ptr->price);            // Update quantities or remove orders            if (buy_ptr->quantity > trade_qty) buy_ptr->quantity -= trade_qty;            else buy_ptr = buy_ptr->next;            if (sell_ptr->quantity > trade_qty) sell_ptr->quantity -= trade_qty;            else sell_ptr = sell_ptr->next;        } else {            break; // No further matches        }    }    atomic_store(&buy_head, buy_ptr);    atomic_store(&sell_head, sell_ptr);}// Simulate stock trading in multiple threadsvoid* simulate_trading(void* arg) {    const char* tickers[] = {"AAPL", "TSLA", "GOOGL", "MSFT", "AMZN"};    while (1) {        char type = (rand() % 2) ? 'B' : 'S';        int quantity = (rand() % 50) + 1;        double price = (rand() % 1000) / 10.0 + 50.0;        const char* ticker = tickers[rand() % 5];        if (type == 'B') add_buy_order(ticker, quantity, price);        else add_sell_order(ticker, quantity, price);        match_orders();        usleep(500000); // 0.5-second delay    }    return NULL;}// Main function to start trading simulationint main() {    srand(time(NULL));    // Create multiple trading threads    pthread_t traders[5];    for (int i = 0; i < 5; i++) {        pthread_create(&traders[i], NULL, simulate_trading, NULL);    }    // Keep the main thread running    for (int i = 0; i < 5; i++) {        pthread_join(traders[i], NULL);    }    return 0;}